using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.CSharp;
using System;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using System.Threading;

namespace EndpointMapper.SourceGenerator;

[Generator]
public class MapMethodsGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var endpoints = context.SyntaxProvider
            .CreateSyntaxProvider(predicate: (node, _) => node is ClassDeclarationSyntax, transform: SyntaxEndpointTransformer)
            .Where(classInformation => classInformation is { Methods.Count: > 0 })
            .Collect();

        context.RegisterSourceOutput(source: endpoints, action: SourceOutputAction);
    }

    private static EndpointClassInformation SyntaxEndpointTransformer(GeneratorSyntaxContext context, CancellationToken ct)
    {
        var classSymbol = context.SemanticModel.GetDeclaredSymbol((ClassDeclarationSyntax) context.Node);
        var endpointInterface = context.SemanticModel.Compilation.GetTypeByMetadataName("EndpointMapper.IEndpoint");
        var registerInterface = context.SemanticModel.Compilation.GetTypeByMetadataName("EndpointMapper.IRegisterEndpoint");
        var configureInterface = context.SemanticModel.Compilation.GetTypeByMetadataName("EndpointMapper.IConfigureEndpoint");

        if (
            classSymbol is null ||
            endpointInterface is null ||
            registerInterface is null ||
            configureInterface is null ||
            !classSymbol.Interfaces.Contains(endpointInterface)
        )
            return new EndpointClassInformation
            {
                Methods = Array.Empty<ISymbol>(),
                ConfigureImplemented = false,
                RegisterImplemented = false,
            };

        var methods = classSymbol
            .GetMembers()
            .Where(symbol => symbol is { IsStatic: true, Kind: SymbolKind.Method })
            .ToArray();
        
        return new EndpointClassInformation
        {
            Methods = methods,
            RegisterImplemented = classSymbol.Interfaces.Contains(registerInterface),
            ConfigureImplemented = classSymbol.Interfaces.Contains(configureInterface)
        };
    }

    private static void SourceOutputAction(
        SourceProductionContext context, 
        ImmutableArray<EndpointClassInformation> endpoints)
    {
        var strBuilder = new StringBuilder();

        foreach (var (methods, registerImplemented, configureImplemented) in endpoints)
        {
            var containingType = methods[0].ContainingType.ToDisplayString();

            strBuilder.AppendLine();
            strBuilder.AppendLine($"            // Mapping endpoints in {containingType}");

            if (registerImplemented)
                strBuilder.AppendLine($"            global::{containingType}.Register(builder);");

            var methodInformationArray = methods
                .SelectMany(method => method.GetAttributes().Select(attribute => new EndpointMethodAttributes{ Method =method, Attribute = attribute}))
                .Where(methodAttributes => methodAttributes.Attribute.AttributeClass is { Name: "HttpMapAttribute", ContainingNamespace.Name: "EndpointMapper" })
                .Select(GetAttributeConstructorValues)
                .Where(methodInfo => methodInfo is { Routes.Count: > 0 });
            
            foreach (var methodInformation in methodInformationArray)
            {
                MapRoutes(strBuilder, methodInformation, configureImplemented, containingType);
            }
        }

        context.AddSource("Endpoints.g.cs", $$"""
            // <auto-generated/>

            #nullable enable

            namespace EndpointMapper
            {
                public static class EndpointMapperExtensions
                {
                    private static readonly string[] ConnectVerb = new[] { "CONNECT" };
                    private static readonly string[] HeadVerb = new[] { "HEAD" };
                    private static readonly string[] OptionsVerb = new[] { "OPTIONS" };
                    private static readonly string[] TraceVerb = new[] { "TRACE" };

                    public static global::Microsoft.AspNetCore.Routing.IEndpointRouteBuilder MapEndpointMapperEndpoints(this global::Microsoft.AspNetCore.Routing.IEndpointRouteBuilder builder)
                    {{{strBuilder}}
                        return builder;
                    }
                }
            }
            """);
    }

    private static void MapRoutes(StringBuilder strBuilder, EndpointMethodInformation methodInformation, bool configureImplemented, string containingType)
    {
        foreach (var route in methodInformation.Routes)
        {
            // Get, Post, Put, Delete, Patch have a built-in method so we use those.
            var builderMethod = methodInformation.HttpVerb switch
            {
                "GET" => $"""MapGet(builder, "{route}",""",
                "POST" => $"""MapPost(builder, "{route}",""",
                "PUT" => $"""MapPut(builder, "{route}",""",
                "DELETE" => $"""MapDelete(builder, "{route}",""",
                "PATCH" => $"""MapPatch(builder, "{route}",""",
                _ => $"""MapMethods(builder, "{route}", {GetHttpMethods(methodInformation.HttpVerb)},""",
            };

            var endpointRouterBuilder =
                $"global::Microsoft.AspNetCore.Builder.EndpointRouteBuilderExtensions.{builderMethod} global::{containingType}.{methodInformation.Method.Name})";

            if (!configureImplemented)
            {
                strBuilder.AppendLine($"            {endpointRouterBuilder};");
                continue;
            }

            strBuilder.AppendLine($"""            global::{containingType}.Configure({endpointRouterBuilder}, "{route}", "{methodInformation.HttpVerb}");""");
        }
    }

    private static EndpointMethodInformation GetAttributeConstructorValues(EndpointMethodAttributes methodAttributes)
    {
        var httpMethodArgument = methodAttributes.Attribute.ConstructorArguments[0];
        var routesArgument = methodAttributes.Attribute.ConstructorArguments[1];

        if (httpMethodArgument is not { Kind: TypedConstantKind.Primitive, Value: string httpMethod } ||
            routesArgument is not { Kind: TypedConstantKind.Array, Values: var routes })
        {
            return new EndpointMethodInformation
            {
                Method = methodAttributes.Method,
                HttpVerb = string.Empty,
                Routes = Array.Empty<string>()
            };
        }

        var transformedRoutes = routes
            .Select(x => x.Value)
            .Cast<string>()
            .ToArray();

        return new EndpointMethodInformation
        {
            Method = methodAttributes.Method,
            HttpVerb = httpMethod,
            Routes = transformedRoutes,
        };

    }

    private static string GetHttpMethods(object? httpMethod)
    {
        return httpMethod switch
        {
            "CONNECT" => "ConnectVerb",
            "HEAD" => "HeadVerb",
            "OPTIONS" => "OptionsVerb",
            "TRACE" => "TraceVerb",
            _ => throw new NotSupportedException($"HTTPMethod {httpMethod} is not supported!"),
        };
    }
}
