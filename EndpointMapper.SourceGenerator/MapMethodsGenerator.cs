using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.CSharp;
using System.Linq;
using System.Text;
using System;
using System.Collections.Immutable;
using System.Threading;
using EndpointClassInformation = (Microsoft.CodeAnalysis.IMethodSymbol[] methods, bool implementsRegisterMethod, bool implementsConfigureMethod);

namespace EndpointMapper.SourceGenerator;

[Generator]
public class MapMethodsGenerator : IIncrementalGenerator
{
#if false
    public MapMethodsGenerator()
    {
        if (!System.Diagnostics.Debugger.IsAttached)
        {
            System.Diagnostics.Debugger.Launch();
        }
    }
#endif

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var endpointsInformation = context.SyntaxProvider
            .CreateSyntaxProvider((node, ct) => node is ClassDeclarationSyntax, transform: SyntaxProviderTransformer)
            .Where(x => x is { methods.Length: > 0 })
            .Collect();

        context.RegisterSourceOutput(endpointsInformation, (context, endpointsInformation) =>
        {
            var strBuilder = new StringBuilder();
            // TODO: don't rely on the ConsoleApp namespace
            strBuilder.AppendLine("""
                // <auto-generated/>

                #nullable enable

                namespace ConsoleApp
                {
                    public static partial class Program
                    {
                        private static readonly string[] ConnectVerb = new[] { "CONNECT" };
                        private static readonly string[] HeadVerb = new[] { "HEAD" };
                        private static readonly string[] OptionsVerb = new[] { "OPTIONS" };
                        private static readonly string[] TraceVerb = new[] { "TRACE" };

                        public static partial global::Microsoft.AspNetCore.Builder.WebApplication MapEndpointMapperEndpoints(this global::Microsoft.AspNetCore.Builder.WebApplication app)
                        {
                """);

            foreach (var information in endpointsInformation)
            {
                var (methods, implementsRegisterMethod, implementsConfigureMethod) = information;

                // Check if there are methods to map
                if (methods.Length < 1)
                    continue;

                var containingType = methods[0].ContainingType.ToDisplayString();

                strBuilder.AppendLine($"            // Mapping endpoints in {containingType}");
                
                if (implementsRegisterMethod)
                    strBuilder.AppendLine($"            global::{containingType}.Register(app);");

                foreach (var method in methods)
                {
                    var methodAttributes = method.GetAttributes();
                    var mapAttributes = methodAttributes
                        .Where(x => x.AttributeClass is { Name: "HttpMapAttribute", ContainingNamespace.Name: "EndpointMapper" });

                    foreach (var attribute in mapAttributes)
                    {
                        var httpMethodArgument = attribute.ConstructorArguments[0];
                        var routesArgument = attribute.ConstructorArguments[1];

                        if (!IsValidAttribute(httpMethodArgument, routesArgument, out var httpMethod, out var routes))
                            continue;

                        foreach (var route in routes)
                        {
                            // Get, Post, Put, Delete, Patch have a built-in method so we use that.
                            var endpointRouteBuilderMethod = httpMethod switch
                            {
                                "GET" => $@"MapGet(app, ""{route}"",",
                                "POST" => $@"MapPost(app, ""{route}"",",
                                "PUT" => $@"MapPut(app, ""{route}"",",
                                "DELETE" => $@"MapDelete(app, ""{route}"",",
                                "PATCH" => $@"MapPatch(app, ""{route}"",",
                                _ => $@"MapMethods(app, ""{route}"", {GetVerb(httpMethod)},",
                            };

                            var endpointRouterBuilder = $$"""global::Microsoft.AspNetCore.Builder.EndpointRouteBuilderExtensions.{{endpointRouteBuilderMethod}} global::{{containingType}}.{{method.Name}})""";

                            if (!implementsConfigureMethod)
                            {
                                strBuilder.AppendLine($"            {endpointRouterBuilder};");
                                continue;
                            }

                            strBuilder.AppendLine($$"""
                                        global::{{containingType}}.Configure(
                                            {{endpointRouterBuilder}},
                                            "{{route}}",
                                            "{{httpMethod}}"
                                        );
                            """);
                        }
                    }
                }

                strBuilder.AppendLine("");
            }

            strBuilder.Append("""
                            return app;
                        }
                    }
                }
                """);

            context.AddSource("Program.g.cs", strBuilder.ToString());
        });
    }

    private static string GetVerb(object? httpMethod)
    {
        return httpMethod switch
        {
            "CONNECT" => "ConnectVerb",
            "HEAD" => "HeadVerb",
            "OPTIONS" => "OptionsVerb",
            "TRACE" => "TraceVerb",
            _ => throw new NotSupportedException($"HTTPMethod {httpMethod} is not supported!"),
        };
    }

    private static bool IsValidAttribute(TypedConstant httpMethodArgument, TypedConstant routesArgument, out string httpMethod, out string[] routes)
    {
        httpMethod = null!;
        routes = null!;

        if (httpMethodArgument is not { Kind: TypedConstantKind.Primitive, Value: string httpMethodOut })
            return false;

        httpMethod = httpMethodOut;

        if (routesArgument is not { Kind: TypedConstantKind.Array, Values: ImmutableArray<TypedConstant> routesArray })
            return false;

        if (routesArray.Select(x => x.Value).Cast<string>().ToArray() is not string[] routesOut)
            return false;

        routes = routesOut;

        return true;
    }

    private static EndpointClassInformation SyntaxProviderTransformer(GeneratorSyntaxContext context, CancellationToken ct)
    {
        var classSymbol = context.SemanticModel.GetDeclaredSymbol((ClassDeclarationSyntax) context.Node);

        var endpointInterface = context.SemanticModel.Compilation.GetTypeByMetadataName("EndpointMapper.IEndpoint");
        var endpointRegisterInterface = context.SemanticModel.Compilation.GetTypeByMetadataName("EndpointMapper.IRegisterEndpoint");
        var endpointConfigureInterface = context.SemanticModel.Compilation.GetTypeByMetadataName("EndpointMapper.IConfigureEndpoint");

        if (
            classSymbol is null || 
            endpointInterface is null || 
            endpointRegisterInterface is null || 
            endpointConfigureInterface is null || 
            !classSymbol.Interfaces.Contains(endpointInterface)
        )
            return (Array.Empty<IMethodSymbol>(), false, false);

        var methods = classSymbol
            .GetMembers()
            .OfType<IMethodSymbol>()
            .Where(x => x.IsStatic)
            .ToArray();

        return (
            methods,
            classSymbol.Interfaces.Contains(endpointRegisterInterface),
            classSymbol.Interfaces.Contains(endpointConfigureInterface)
        );
    }
}
