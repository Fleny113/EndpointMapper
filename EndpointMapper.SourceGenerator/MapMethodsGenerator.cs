using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.CSharp;
using System;
using System.Collections.Immutable;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Threading;

namespace EndpointMapper.SourceGenerator;

[Generator]
public class MapMethodsGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var endpoints = context.SyntaxProvider
            .CreateSyntaxProvider(predicate: (node, _) => node is ClassDeclarationSyntax, transform: SyntaxEndpointTransformer)
            .Where(x => x is not null)
            .Select((x, _) => x!)
            .Collect();

        context.RegisterSourceOutput(source: endpoints, action: SourceOutputAction);
    }

    private static EndpointClassInformation? SyntaxEndpointTransformer(GeneratorSyntaxContext context, CancellationToken ct)
    {
        var classSymbol = context.SemanticModel.GetDeclaredSymbol((ClassDeclarationSyntax)context.Node);
        var endpointInterface = context.SemanticModel.Compilation.GetTypeByMetadataName("EndpointMapper.IEndpoint");
        var registerInterface = context.SemanticModel.Compilation.GetTypeByMetadataName("EndpointMapper.IRegisterEndpoint");
        var configureInterface = context.SemanticModel.Compilation.GetTypeByMetadataName("EndpointMapper.IConfigureEndpoint");
        var httpMapAttribute = context.SemanticModel.Compilation.GetTypeByMetadataName("EndpointMapper.HttpMapAttribute");

        if (
            // Check that we could get the necessary symbols from the EndpointMapper assembly.
            classSymbol is null ||
            endpointInterface is null ||
            registerInterface is null ||
            configureInterface is null ||
            httpMapAttribute is null ||
            // Check that the class implements the IEndpoint interface.
            !classSymbol.Interfaces.Contains(endpointInterface)
        ) return null;

        var endpoints = classSymbol
            .GetMembers()
            .Where(symbol => symbol is { IsStatic: true, Kind: SymbolKind.Method })
            .SelectMany(
                method => method.GetAttributes().Where(attribute =>
                    attribute.AttributeClass is not null &&
                    attribute.AttributeClass.Equals(httpMapAttribute, SymbolEqualityComparer.Default)),
                GetEndpointMethodInformation)
            .ToList();

        var registerMethod = endpointInterface.GetMembers().First(x => x.Name == "Register");
        var endpointRegisterMethod = classSymbol.FindImplementationForInterfaceMember(registerMethod);

        var configureMethod = endpointInterface.GetMembers().First(x => x.Name == "Configure");
        var endpointConfigurerMethod = classSymbol.FindImplementationForInterfaceMember(configureMethod);

        var hasRegisterImplemented =
            (endpointRegisterMethod is not null &&
             endpointRegisterMethod.ContainingType.Equals(classSymbol, SymbolEqualityComparer.Default)) ||
            classSymbol.Interfaces.Contains(registerInterface);

        var hasConfigureImplemented =
            (endpointConfigurerMethod is not null &&
             endpointConfigurerMethod.ContainingType.Equals(classSymbol, SymbolEqualityComparer.Default)) ||
            classSymbol.Interfaces.Contains(configureInterface);

        return new EndpointClassInformation(Endpoints: endpoints, ClassSymbol: classSymbol,
            RegisterImplemented: hasRegisterImplemented, ConfigureImplemented: hasConfigureImplemented);
    }

    private static void SourceOutputAction(SourceProductionContext context, ImmutableArray<EndpointClassInformation> endpointClasses)
    {
        using var stringWriter = new StringWriter(CultureInfo.InvariantCulture);
        using var codeWriter = new CodeWriter(stringWriter, baseIndent: 0);

        codeWriter.WriteLine("// <auto-generated/>");
        codeWriter.WriteLine("#nullable enable");
        codeWriter.WriteLine();
        codeWriter.WriteLine("namespace EndpointMapper");
        codeWriter.StartBlock();
        codeWriter.WriteLine("public static class EndpointMapperExtensions");
        codeWriter.StartBlock();

        var allEndpoints = endpointClasses.SelectMany(x => x.Endpoints).ToArray();
        var connectNeeded = allEndpoints.Any(x => x.HttpVerb == "CONNECT");
        var headNeeded = allEndpoints.Any(x => x.HttpVerb == "HEAD");
        var optionsNeeded = allEndpoints.Any(x => x.HttpVerb == "OPTIONS");
        var traceNeeded = allEndpoints.Any(x => x.HttpVerb == "TRACE");

        if (connectNeeded)
            codeWriter.WriteLine("private static readonly string[] ConnectVerb = [\"CONNECT\"];");
        if (headNeeded)
            codeWriter.WriteLine("private static readonly string[] HeadVerb = [\"HEAD\"];");
        if (optionsNeeded)
            codeWriter.WriteLine("private static readonly string[] OptionsVerb = [\"OPTIONS\"];");
        if (traceNeeded)
            codeWriter.WriteLine("private static readonly string[] TraceVerb = [\"TRACE\"];");

        codeWriter.WriteLine("public static global::Microsoft.AspNetCore.Routing.IEndpointRouteBuilder MapEndpointMapperEndpoints(this global::Microsoft.AspNetCore.Routing.IEndpointRouteBuilder builder)");
        codeWriter.StartBlock();

        foreach (var (endpoints, classSymbol, registerImplemented, configureImplemented) in endpointClasses)
        {
            var containingType = classSymbol.ToDisplayString();

            codeWriter.WriteLine($"// Mapping endpoints in {containingType}");

            if (registerImplemented)
                codeWriter.WriteLine($"global::{containingType}.Register(builder);");

            foreach (var methodInformation in endpoints)
            {
                MapRoutes(codeWriter, methodInformation, configureImplemented, containingType);
            }

            codeWriter.WriteLine();
        }

        codeWriter.WriteLine("return builder;");
        codeWriter.EndBlock(); // End of MapEndpointMapperEndpoints
        codeWriter.EndBlock(); // End of EndpointMapperExtensions
        codeWriter.EndBlock(); // End of namespace EndpointMapper

        context.AddSource("Endpoints.g.cs", stringWriter.ToString());
    }

    private static EndpointMethodInformation GetEndpointMethodInformation(ISymbol method, AttributeData attribute)
    {
        var httpMethodArgument = attribute.ConstructorArguments[0];
        var routesArgument = attribute.ConstructorArguments[1];

        if (httpMethodArgument is not { Kind: TypedConstantKind.Primitive, Value: string httpMethod } ||
            routesArgument is not { Kind: TypedConstantKind.Array, Values: var routes })
        {
            return new EndpointMethodInformation(Method: method, HttpVerb: string.Empty, Routes: []);
        }

        var transformedRoutes = routes
            .Select(x => x.Value)
            .Cast<string>()
            .ToList();

        return new EndpointMethodInformation(Method: method, HttpVerb: httpMethod, Routes: transformedRoutes);
    }

    private static void MapRoutes(CodeWriter codeWriter, EndpointMethodInformation methodInformation, bool configureImplemented, string containingType)
    {
        foreach (var route in methodInformation.Routes)
        {
            // Get, Post, Put, Delete, Patch have a built-in method so we use those, for the other methods we need to use MapMethods.
            var builderMethod = methodInformation.HttpVerb switch
            {
                "GET" => $"""MapGet(builder, "{route}",""",
                "POST" => $"""MapPost(builder, "{route}",""",
                "PUT" => $"""MapPut(builder, "{route}",""",
                "DELETE" => $"""MapDelete(builder, "{route}",""",
                "PATCH" => $"""MapPatch(builder, "{route}",""",
                "CONNECT" => $"""MapMethods(builder, "{route}", ConnectVerb,""",
                "HEAD" => $"""MapMethods(builder, "{route}", HeadVerb,""",
                "OPTIONS" => $"""MapMethods(builder, "{route}", OptionsVerb,""",
                "TRACE" => $"""MapMethods(builder, "{route}", TraceVerb,""",
                _ => throw new NotSupportedException($"HTTPMethod {methodInformation.HttpVerb} is not supported!"),
            };

            var endpointRouterBuilder =
                $"global::Microsoft.AspNetCore.Builder.EndpointRouteBuilderExtensions.{builderMethod} global::{containingType}.{methodInformation.Method.Name})";

            if (!configureImplemented)
            {
                codeWriter.WriteLine($"{endpointRouterBuilder};");
                continue;
            }

            codeWriter.WriteLine($"""global::{containingType}.Configure({endpointRouterBuilder}, "{route}", "{methodInformation.HttpVerb}");""");
        }
    }
}
