using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.CSharp;
using System.Linq;
using System.Text;
using System;
using System.Collections.Generic;

namespace EndpointMapper.SourceGenerator;

[Generator]
public class MapMethodsGenerator : IIncrementalGenerator
{
#if DEBUG
    public MapMethodsGenerator()
    {
        if (!System.Diagnostics.Debugger.IsAttached)
        {
            // System.Diagnostics.Debugger.Launch();
        }
    }
#endif

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var methodsGroupedByClasses = context.SyntaxProvider
            .CreateSyntaxProvider(
                (node, ct) => node is ClassDeclarationSyntax,
                (context, ct) =>
                {
                    var model = context.SemanticModel;
                    var classDeclaration = (ClassDeclarationSyntax)context.Node;
                    var classSymbol = model.GetDeclaredSymbol(classDeclaration);
                    var interfaceType = model.Compilation.GetTypeByMetadataName("EndpointMapper.IEndpoint");

                    if (classSymbol is null || interfaceType is null)
                        return null!;

                    if (classSymbol.Interfaces.Contains(interfaceType))
                        return classSymbol.GetMembers().OfType<IMethodSymbol>().ToArray();

                    return null!;
                }
            )
            .Where(x => x is not null)
            .Collect();

        context.RegisterSourceOutput(methodsGroupedByClasses, (context, methodsGroupedByClasses) =>
        {
            _instancesCreated.Clear();

            var strBuilder = new StringBuilder();
            // TODO: don't rely on the ConsoleApp namespace
            strBuilder.Append("""
                // <auto-generated/>

                #nullable disable

                namespace ConsoleApp
                {
                    public partial class Program
                    {
                        private static readonly string[] ConnectVerb = new[] { "CONNECT" };
                        private static readonly string[] HeadVerb = new[] { "HEAD" };
                        private static readonly string[] OptionsVerb = new[] { "OPTIONS" };
                        private static readonly string[] TraceVerb = new[] { "TRACE" };

                        public static partial global::Microsoft.AspNetCore.Builder.WebApplication HelloFrom(global::Microsoft.AspNetCore.Builder.WebApplication app, bool addMiddleware)
                        {
                            if (addMiddleware)
                                global::Microsoft.AspNetCore.Builder.UseMiddlewareExtensions.UseMiddleware<global::EndpointMapper.EndpointMapperMiddleware>(app);

                """);

            strBuilder.AppendLine("");

            foreach (var methods in methodsGroupedByClasses)
            {
                foreach (var method in methods)
                {
                    var methodAttributes = method.GetAttributes();
                    var mapAttributes = methodAttributes
                        .Where(x => x.AttributeClass is { Name: "HttpMapAttribute", ContainingNamespace.Name: "EndpointMapper" });

                    foreach (var attribute in mapAttributes)
                    {
                        var httpMethodArgument = attribute.ConstructorArguments[0];
                        var routesArgument = attribute.ConstructorArguments[1];

                        if (httpMethodArgument.Kind is not TypedConstantKind.Primitive || routesArgument.Kind is not TypedConstantKind.Array)
                            continue;

                        var httpMethod = httpMethodArgument.Value;
                        var routes = routesArgument.Values.Select(x => x.Value).ToArray();

                        foreach (var route in routes)
                        {
                            // Get, Post, Put, Delete, Patch have a built-in method so we use that.
                            var endpointRouteBuilderMethod = httpMethod switch
                            {
                                "GET" => $@"MapGet(app, ""{route}"",",
                                "POST" => $@"MapPost(app, ""{route}"",",
                                "PUT" => $@"MapPut(app, ""{route}"",",
                                "DELETE" => $@"MapDelete(app, ""{route}"",",
                                "PATCH" => $@"MapPatch(app, ""{route}"",",
                                _ => $@"MapMethods(app, ""{route}"", {GetVerb(httpMethod)},",
                            };

                            var (containingVariable, isInstance) = GetContainingVariable(method, strBuilder);

                            strBuilder.Append($"            global::Microsoft.AspNetCore.Builder.EndpointRouteBuilderExtensions.{endpointRouteBuilderMethod} {containingVariable}.{method.Name})");

                            if (isInstance)
                                strBuilder.Append($".WithMetadata({containingVariable})");

                            strBuilder.AppendLine(";");
                        }
                    }
                }

                strBuilder.AppendLine("");
            }

            strBuilder.Append("""

                            return app;
                        }
                    }
                }
                """);

            context.AddSource("Program.g.cs", strBuilder.ToString());
        });
    }

    private static readonly List<string> _instancesCreated = new();

    private static string GetVerb(object? httpMethod)
    {
        return httpMethod switch
        {
            "CONNECT" => "ConnectVerb",
            "HEAD" => "HeadVerb",
            "OPTIONS" => "OptionsVerb",
            "TRACE" => "TraceVerb",
            _ => throw new NotSupportedException($"HttpMethod {httpMethod} is not supported!"),
        };
    }

    private static string GetEndpointInstanceName(string containingType)
    {
        return containingType.Replace(".", "");
    }

    private static (string containingVariable, bool isInstance) GetContainingVariable(IMethodSymbol method, StringBuilder strBuilder)
    {
        var containingType = method.ContainingType.ToDisplayString();

        if (method.IsStatic)
            return ($"global::{containingType}", false);

        var instanceName = GetEndpointInstanceName(containingType);

        if (!_instancesCreated.Contains(instanceName))
        {
            var ctor = method.ContainingType.GetMembers(".ctor").FirstOrDefault() as IMethodSymbol;
            var paramsCount = ctor?.Parameters.Length ?? 0;

            var nullParameters = new StringBuilder().Insert(0, "null, ", paramsCount).ToString();
            var parameters = nullParameters.Length > 2 ? nullParameters.Remove(nullParameters.Length - 2) : nullParameters;

            strBuilder.AppendLine($"            var {instanceName} = new global::{containingType}({parameters});");
            _instancesCreated.Add(instanceName);
        }

        return (instanceName, true);
    }
}
